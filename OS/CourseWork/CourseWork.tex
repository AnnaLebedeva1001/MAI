\documentclass[a4paper,12pt]{extarticle}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}

\usepackage[dvips]{graphicx}
\usepackage{color}
\usepackage[dvips]{hyperref}

\usepackage{setspace}
\usepackage{indentfirst}
\usepackage{textcomp}
\usepackage{ifthen}
\usepackage{calc}

\usepackage[cache=false]{minted}

\hypersetup{%
	unicode,%
	linkcolor=blue,
	colorlinks=true,%
%	pdfpagemode=FullScreen,%
%	pdfpagetransition=Dissolve,%
	pdftitle={Курсовая работа по дисциплине "Операционные системы и архитектура ПК"},%
}

\thispagestyle{empty}

\setlength{\voffset}{-.8in}
\setlength{\hoffset}{-.75in}
\addtolength{\textheight}{1.6in}
\addtolength{\textwidth}{1.5in}


\onehalfspacing

%Поменяйте фамилию, имя и отчество в команде FIO
\newcommand{\FIO}{Лебедева Анна Ильинична}

%Поменяйте название программного продукта в команде SOFTWARE
\newcommand{\SOFTWARE}{Преобразователь кодировки переданного файла (CP1251, CP866, Koi-8r)}

%Укажите номер группы (210 или 211)
\newcommand{\GROUP}{210}

\setcounter{tocdepth}{2}
\begin{document}
\input{titulCW}
\newpage

\tableofcontents
\newpage
\
\part{Теоретическая}

\section{Гонка данных}
%Вставить название вопроса 1
%Описать теоретический вопрос № 1
В некоторых операционных системах процессы, работающие совместно, могут сообща использовать некое общее хранилище данных.

Каждый из процессов может считывать из общего хранилища данных и записывать туда информацию.

Это хранилище представляет собой участок в основной памяти (возможно, в структуре данных ядра) или файл общего доступа. Местоположение совместно используемой памяти не влияет на суть взаимодействия и возникающие проблемы.

Ситуации, в которых два (и более) процесса считывают или записывают данные одновременно и конечный результат зависит от того, какой из них был первым, называются состояниями состязания.

Отладка программы, в которой возможно состояние состязания, вряд ли может доставить удовольствие. Результаты большинства тестовых прогонов будут хорошими, но изредка будет происходить нечто странное и необъяснимое.

Как избежать состязания?

Основным способом предотвращения проблем в этой и любой другой ситуации, связанной с совместным использованием памяти, файлов и чего-либо ещё, является запрет одновременной записи и чтения разделенных данных более чем одним процессом.

Говоря иными словами, необходимо взаимное исключение. Это означает, что в тот момент, когда один процесс использует разделенные данные, другому процессу это делать будет запрещено.

Некоторый промежуток времени процесс занят внутренними расчетами и другими задачами, не приводящими к состояниям состязания. В другие моменты времени процесс обращается к совместно используемым данным или выполняет какое-то другое действие, которое может привести к состязанию.

Часть программы, в которой есть обращение к совместно используемым данным, называется критической областью или критической секцией. Если нам удастся избежать одновременного нахождения двух процессов в критических областях, мы сможем избежать состязаний.

Несмотря на то что это требование исключает состязание, его недостаточно для правильной совместной работы параллельных процессов и эффективного использования общих данных. Для этого необходимо выполнение четырех условий:
\begin{itemize}
\itemДва процесса не должны одновременно находиться в критических областях.
\itemВ программе не должно быть предположений о скорости или количестве процессоров.
\itemПроцесс, находящийся вне критической области, не может блокировать другие процессы.
\itemНевозможна ситуация, в которой процесс вечно ждет попадания в критическую область.
\end{itemize}
Методы разрешения:

Запрещение прерываний

В однопроцессорных системах простейшим решением является запрещение всех прерываний каждым процессом сразу после входа в свою критическую область и их разрешение после выхода из нее. Однако если один из процессов выключил и не включил прерывания, это может вызвать крах всей системы. Запрещение прерываний --- очень удобное средство для самого ядра, когда оно обновляет переменные или списки. Например, когда прерывание происходит в момент изменения состояния списка готовых процессов, может сложиться состязательная ситуация. Поэтому запрещение прерываний является полезной технологией внутри самой ОС, но не подходит в качестве механизма взаимных блокировок для пользовательских процессов.

Блокирующие переменные

Если использовать общую блокирующую переменную, нулевое значение которой показывает, что ни один из процессов не находится в своей критической области, а единица — что какой-то процесс находится в своей критической области. Исходное значение такой блокирующей переменной равно 0. Когда процессу требуется войти в свою критическую область, сначала он проверяет значение блокирующей переменной. Если оно равно 0, процесс устанавливает его в 1 и входит в критическую область. Если значение уже равно 1, процесс ожидает, пока оно не станет равно 0. К сожалению, использование блокирующей переменной (так же как в примере с каталогом спулера) не позволяет избежать возникновения состязательной ситуации.

Спинлок

Постоянная проверка значения переменной (занято-свободно), пока она не приобретёт какое-нибудь значение, называется активным ожиданием. Обычно его следует избегать, поскольку оно тратит впустую процессорное время. Активное ожидание используется только в том случае, если оно будет недолгим. Блокировка, использующая активное ожидание,  называется циклической блокировкой (спин-блокировкой, спинлок). Алгоритм спин-блокировки позволяет предотвращать любые состязательные ситуации, но нарушает третье условие: процесс оказывается заблокированным тем процессом, который не находится в своей критической области. Это станет заметно, когда один процесс работает существенно медленнее друго.

Алгоритм Петерсона

Перед тем, как начать исполнение критической секции кода, поток должен вызвать специальную процедуру (назовем её lock()) со своим номером в качестве параметра. Она должна организовать ожидание потоком своей очереди входа в критическую секцию. После исполнения критической секции и выхода из неё поток вызывает другую процедуру (назовем её unlock()), после чего уже другие потоки смогут войти в критическую область. Посмотрим, как реализуется этот общий принцип алгоритмом Петерсона для двух потоков. 

TSL

(TSL — Test and Set Lock, то есть проверь и установи блокировку), которая работает следующим образом. Она считывает содержимое слова памяти lock в регистр RX, а по адресу памяти, отведенному для lock, записывает ненулевое значение. При этом гарантируются неделимость операций чтения слова и сохранение в нем нового значения — никакой другой процесс не может получить доступ к слову в памяти, пока команда не завершит свою работу. Центральный процессор, выполняющий команду TSL, блокирует шину памяти, запрещая другим центральным процессорам доступ к памяти до тех пор, пока не будет выполнена эта команда.

\section{Управление памятью без использования абстракций}
%Вставить название вопроса 2
%Описать теоретический вопрос № 2
Простейшей абстракцией памяти можно считать полное отсутствие какой-либо абстракции. В условиях, когда в качестве модели памяти выступает сама физическая память, возможны несколько вариантов использования памяти. Операционная система может размещаться в нижней части адресов, в оперативном запоминающем устройстве (ОЗУ), или, по-другому, в памяти с произвольным доступом — RAM (Random Access Memory). Она может размещаться также в постоянном запоминающем устройстве (ПЗУ), или, иначе, в ROM (Read-Only Memory), в верхних адресах памяти. Или же драйверы устройств могут быть в верхних адресах памяти, в ПЗУ, а остальная часть системы — в ОЗУ, в самом низу. Первая модель прежде использовалась на универсальных машинах и мини-компьютерах, а на других машинах — довольно редко. Вторая модель использовалась на некоторых КПК и встроенных системах. Третья модель использовалась на ранних персональных компьютерах (например, на тех, которые работали под управлением MS-DOS), где часть системы, размещавшаяся в ПЗУ, называлась базовой системой ввода-вывода — BIOS (Basic Input Output System). Недостаток данных моделей заключается в том, что ошибка в программе пользователя может затереть операционную систему, и, возможно, с весьма пагубными последствиями.

Единственный способ добиться хоть какой-то параллельности в системе, не имеющей абстракций памяти, — это запустить программу с несколькими потоками. Для этого операционная система должна сохранить все содержимое памяти в файле на диске, а затем загрузить и запустить следующую программу. Поскольку одновременно в памяти присутствует только одна программа, конфликтов не возникает. Эта концепция называется заменой данных (или свопингом).

При наличии некоторого специального дополнительного оборудования появляется возможность параллельного запуска нескольких программ даже без использования свопинга. Аппаратное обеспечение IBM 360 перехватывало любую попытку запущенного процесса получить доступ к памяти с ключом защиты, отличающимся от ключа PSW. Поскольку изменить ключи защиты могла только операционная система, пользовательские процессы были защищены от вмешательства в работу друг друга и в работу самой операционной системы.

Тем не менее это решение имело серьезный недостаток. Когда две программы загружаются друг за другом в память, начиная с ячейки с адресом 0, мы получаем проблему перемещения.

После загрузки программы могут быть запущены на выполнение. Поскольку у них разные ключи памяти, ни одна из них не может навредить другой. Но проблема имеет иную природу. При запуске первой программы будет осуществлен переход к другой команде. Эта программа будет успешно работать. Но после того как первая программа проработает достаточно долго, операционная система может принять решение на запуск второй программы, которая была загружена над первой программой, начиная с некоторого адреса. Скорее всего, это приведёт к сбою программы на первой же секунде.

В данном случае суть проблемы состоит в том, что обе программы ссылаются на абсолютный адрес физической памяти, что совершенно не соответствует нашим желаниям. Нам нужно, чтобы каждая программа ссылалась на занимаемый ею набор адресов.

Вкратце рассмотрим, как это достигается. На IBM 360, например, в процессе загрузки буквально на лету осуществлялась модификация второй программы, при этом использовалась технология, известная как статическое перемещение. Она работала следующим образом: когда программа загружалась с адреса 16 384, в процессе загрузки к каждому адресу в программе прибавлялось постоянное значение 16 384. При всей исправности работы этого механизма он был не самым универсальным решением, и к тому же замедлял загрузку. Более того, это решение требовало дополнительной информации обо всех исполняемых программах, сообщающей, в каких словах содержатся, а в каких не содержатся перемещаемые адреса. В результате чего должно было подвергнуться перемещению, а инструкция вроде
\newline MOV REGISTER1,28
\newline которая помещает число 28 в REGISTER1, должна была остаться нетронутой. Нужен был какой-нибудь способ, позволяющий сообщить загрузчику, какое из чисел относится к адресу, а какое — к константе.
\newpage

\part{Практическая}
%В каждом из подразделов нужно описать 
\section{Простые стандартные алгоритмы}
\subsection{Алгоритм Евклида} 
\subsubsection{Техническое задание}
Для 2-х целых чисел вычислить наименьшее общее кратное и наибольший общий делитель по алгоритму Евклида.

\subsubsection{Описание основного алгоритма}
Пользователь вводит целые числа через пробел. Затем функция NOD считает наибольший общий делитель, вычитая одно число из другого пока одно из них не обнулится, а второе будет являться НОД-ом. И потом функция NOK считает наименьшее общее кратное следующим образом: перемножает два данных числа и делит их на НОД, посчитанный первой функцией.

Реализация алгоритма представлена в подразделе \ref{code:evclid}.

\subsubsection{Руководство пользователя}
Пользователю необходимо ввести целые числа(например 5 и 10), и тогда он получит ответ.

(base) [anna@Ultra-asus lab1] \$ ./z1 \newline
Введите целые числа через пробел: 5 10\newline
НОД 5 НОК 10

\subsection{Корректность расстановки скобок}
\subsubsection{Техническое задание}
Проверить  правильность  расстановки  в  тексте  круглых  квадратных и  фигурных скобок.

\subsubsection{Описание основного алгоритма}
Пользователь вводит последовательность скобок, для которой мы завели массив символов A. Далее мы начинаем идти по данному массиву, начиная с нулевого элемента. Если встречается открывающая скобка, то счётчик для данного вида скобок увеличевается, если закрывающая, то уменьшается. Если скобка открывающая, то мы её сохраняем в стек и в переменную end\_open\_skobka. Если любой из счётчиков скобок меньше нуля, то обнаружена лишняя закрывающая скобка. Далее при помощи переменной end\_open\_skobka выясняем, что может быть обнаружена несовпадающая пара открывающей и закрывающей скобок. Затем, если все скобки закрыты верно, то все счётчики должны быть нулевыми, тогда все скобки расставлены верно.

\subsubsection{Руководство пользователя}
Пользователь должен ввести последовательность скобок(например: \{]]\{() )

(base) [anna@Ultra-asus lab1]  \$ ./z2\newline
Введите текст: \newline
[\{()\}]\newline
Скобки расставлены правильно\newline
(base) [anna@Ultra-asus lab1] \$ ./z2\newline
Введите текст: \newline
\{\{[]( \newline
Скобки расставлены неправильно\newline
(base) [anna@Ultra-asus lab1] \$\newline

\subsection{Переполнение}
\subsubsection{Техническое задание}
Для  заданного  целого n вычислить  сумму $1^1+2^2+3^3+...+n^n$.  Динамически определить при каком n произойдет переполнение для типов short, unsigned short, int, unsigned int, long long.

\subsubsection{Описание основного алгоритма}
В начале пользователь вводит число. Если пользователь ввёл отрицательное, то программа просит ввести положительное и завершается. Далее сумма вычисляется по данной формуле. Далее по этой же формуле выясняем переполнение для INT. Когда наша сумма достигнет границы INT, на следующей итерации цикла сумма станет отрицательной, и мы выясним при каком n произойдёт переполнение. Аналогично для остальных типов.

\subsubsection{Руководство пользователя}
Пользователю необходимо ввести целое положительное число(например: 23, 111, 1200)

(base) [anna@Ultra-asus lab1] \$ ./z3 \newline
Напишите число: 24\newline
Число = 24\newline
Сумма = 4900\newline
Переполнение INT начиная с n = 11\newline
Переполнение SHORT INT начиная с n = 6\newline
Переполнение LONG INT начиная с n = 17\newline
Переполнение WORD начиная с n = 7\newline
Переполнение BYTE начиная с n = 7\newline
(base) [anna@Ultra-asus lab1] \$ \newline

\subsection{Куб в виде суммы}
\subsubsection{Техническое задание}
Составить   программу   возведения   в   3   степень   (куб   числа), используя закономерность $1^3=1; 2^3=3+5=8; 3^3=7+9+11=27; 4^3=13+15+17+19=64$, ...

\subsubsection{Описание основного алгоритма}
Пользователь вводит число n. Затем по формуле $n * (n - 1)$ мы считаем первый элемент суммы. И затем в цикле, прибавляя к предыдущему элементу 2, получаем следующий и прибавляем его к предыдущему. Таким образом мы посчитаем куб числа, используя данную закономерность.

\subsubsection{Руководство пользователя}
Пользователю нужно ввести целое положительное число (например: 4)

(base) [anna@Ultra-asus lab1] \$ ./z4\newline
Ведите число для возведения в третью степень: 5\newline
$5^3 = 21+23+25+27+29 = 125$(base) [anna@Ultra-asus lab1] \$\newline

\subsection{Числа Фибоначчи}
\subsubsection{Техническое задание}
Числа  Фибоначчи  определяются  соотношениями: $f_0=f_1=1;f_n={f_p}+{f_k}$, где p = n - 1 и k = n - 2. Составить программу  поиска первого числа  Фибоначчи  (и  его  номера),  большего заданного m.
\subsubsection{Описание основного алгоритма}
Пользователь вводит число m. В цикле осуществляется поиск подходящего числа по заданному соотношению. Если a на выходе из цикла получилось равно заданному m, то мы считаем следующее число Фибоначчи. Таким образом мы найдём первое число Фибоначчи больше заданного m.

\subsubsection{Руководство пользователя}
Пользователь вводит целое положительное число и получает ответ.

(base) [anna@Ultra-asus lab1] \$ ./z5 \newline
27\newline
№9; число Фибоначи: 34\newline
(base) [anna@Ultra-asus lab1] \$ \newline

\subsection{Сумма квадратов}
\subsubsection{Техническое задание}
Составить  программу,  определяющую  можно  ли  заданное  натуральное число представить в виде суммы квадратов двух натуральных чисел. Если это возможно, то вывести эти квадраты (все возможные).

\subsubsection{Описание основного алгоритма}
Пользователь вводит натуральное число. И далее в двойном цикле for считаются все случаи суммы квадратов двух натуральных чисел. Если такая находится, то мы её печатаем.

\subsubsection{Руководство пользователя}
Пользователю нужно ввести целое положительное число.

(base) [anna@Ultra-asus lab1] \$ ./z6 \newline
25\newline
9 16 \newline
16 9 \newline
(base) [anna@Ultra-asus lab1] \$ ./z6 \newline
189\newline
(base) [anna@Ultra-asus lab1] \$\newline

\newpage

\section{Работа с файловой системой}
\subsection{Используемые системные объекты}

<sys/types.h> --- заголовок, для использования разных типов данных, например, которые нужны для получения информации о файле;

<sys/stat.h> --- заголовок, который содержит функцию lstat, возвращающая информацию о файле в буфер;

<unistd.h> --- это имя файла заголовка, обеспечивающего доступ к API операционной системы POSIX(open - открыть файл, link - создать жёсткую ссылку на файл, symlink - символическую и т.д.);

<fcntl.h> --- данный заголовок нужен для работы с файловыми дескрипторами;

<dirent.h> --- содержит определения структур данных каталога, а также прототипы функций работы с каталогами opendir(), readdir().



\subsection{Реализация ls}
\subsubsection{Техническое задание}
Вывести   на   экран   все   файлы,   расположенные в директории,   введённой пользователем.

\subsubsection{Описание основного алгоритма}
Программа открывает введённую пользователем директорию, выводит файлы, которые в ней находятся, при этом читая саму директорию, затем закрывает директорию.

\subsubsection{Руководство пользователя}
Пользователь вводит аргументы командной строки: первый --- исполняемый файл, второй --- название директории или путь к ней. Например: ./a.out Desktop

(base) [anna@Ultra-asus lab2]\$ ./z1  /home/anna/projects/3sem/OSIAK/lab2 \newline
. \newline
.. \newline
z1.cpp \newline
z1\newline
z2.cpp\newline
lab\newline
z3.c\newline
f.txt\newline
z3\newline
f.1.txt\newline
f.2.txt\newline
f.3.txt\newline
test4.c\newline
z4.cpp\newline
z4.c\newline
link\newline
z5.cpp\newline
z4\newline
test.txt\newline
link1\newline
z2\newline
z5\newline
f.4.txt\newline
Done...\newline
(base) [anna@Ultra-asus lab2]\$ \newline

\subsection{Реализация ls без папок}
\subsubsection{Техническое задание}
Вывести   на   экран   из   указанной пользователем директории   все файлы, не являющиеся папками.

\subsubsection{Описание основного алгоритма}
Программа открывает введённую пользователем директорию, выводит файлы по следующему принципу: если файл смог открыться как директория, то мы его закрываем и не выводим его название на консоль, если же не смог, то есть при открытии вернул NULL, значит этот файл не директория, и мы его выводим на консоль.

\subsubsection{Руководство пользователя}
Пользователь должен ввести название директории. Например: lab2 или\newline /home/anna/projects/3sem/OSIAK/lab2.


(base) [anna@Ultra-asus lab2]\$ ./z2\newline
Enter directory name: /home/anna/projects/3sem/OSIAK/lab2\newline
z1.cpp\newline
z1\newline
z2.cpp\newline
z3.c\newline
f.txt\newline
z3\newline
f.1.txt\newline
f.2.txt\newline
f.3.txt\newline
test4.c\newline
z4.cpp\newline
z4.c\newline
link\newline
z5.cpp\newline
z4\newline
test.txt\newline
link1\newline
z2\newline
z5\newline
f.4.txt\newline
Done...\newline
(base) [anna@Ultra-asus lab2]\$ ls\newline
f.1.txt  f.4.txt  link     test.txt  z2      z3.c  z4.cpp\newline
f.2.txt  f.txt    link1    z1        z2.cpp  z4    z5\newline
f.3.txt  lab      test4.c  z1.cpp    z3      z4.c  z5.cpp\newline
(base) [anna@Ultra-asus lab2]\$\newline
Директорией в данном примере является папка lab, и данной программой она не вывелась.

\subsection{Жёсткая ссылка}
\subsubsection{Техническое задание}
Открыть  указанный  файл  на  запись.  Если  файл  уже  существует,  сделать  на  него жёсткую  ссылку  (name.x.ext),  где  x --- первый  свободный  номер, ext –-- текущее расширение файла.

\subsubsection{Описание основного алгоритма}
Открываем  указанный  файл  на  запись.  Если  файл  уже  существует, делаем  на  него жёсткую  ссылку. Закрываем файл.

\subsubsection{Руководство пользователя}
Пользователь аргументами командной строки задаёт исполняемый файл, название файла и название жёсткой ссылки на него.\newline
Например: ./z3 f.txt f.1.txt\newline

Смотрим текущую директорию:\newline
(base) [anna@Ultra-asus lab2]\$ ls\newline
f.txt  test4.c   z1      z2      z3    z4    z4.cpp  z5.cpp\newline
lab    test.txt  z1.cpp  z2.cpp  z3.c  z4.c  z5\newline

Создаём жёсткую ссылку:\newline
(base) [anna@Ultra-asus lab2]\$ ./z3 f.txt f.3.txt\newline
(base) [anna@Ultra-asus lab2]\$ ls\newline
f.3.txt  lab      test.txt  z1.cpp  z2.cpp  z3.c  z4.c    z5\newline
f.txt    test4.c  z1        z2      z3      z4    z4.cpp  z5.cpp\newline

Пробуем написать название существующей:\newline
(base) [anna@Ultra-asus lab2]\$ ./z3 f.txt f.3.txt\newline
link: File exists\newline

Как видим создалась ссылка с номером на 1 больше:\newline
(base) [anna@Ultra-asus lab2]\$ ls\newline
f.3.txt  f.txt  test4.c   z1      z2      z3    z4    z4.cpp  z5.cpp\newline
f.4.txt  lab    test.txt  z1.cpp  z2.cpp  z3.c  z4.c  z5\newline
(base) [anna@Ultra-asus lab2]\$ \newline


\subsection{Символическая ссылка}
\subsubsection{Техническое задание}
Создать символическую ссылку на файл с текстом программы по указанному пути и вывести информацию по ней об атрибутах данной символической ссылки.

\subsubsection{Описание основного алгоритма}
Создаём символическую ссылку на файл с текстом программы по указанному пути и выводим информацию по ней об атрибутах данной символической ссылки.

\subsubsection{Руководство пользователя}
Пользователь вводит в командную строку название исполняемого файла, название самого файла и название ссылки на него.\newline

Проверяем директорию:\newline
(base) [anna@Ultra-asus lab2]\$ ls\newline
f.3.txt  f.txt  test4.c   z1      z2      z3    z4    z4.cpp  z5.cpp\newline
f.4.txt  lab    test.txt  z1.cpp  z2.cpp  z3.c  z4.c  z5\newline

Создаём ссылку:\newline
(base) [anna@Ultra-asus lab2]\$ ./z4 test.txt link\newline
устройство - 52\newline
inode - 2861786\newline
режим доступа - 41471\newline
количество жестких ссылок - 1\newline
ID пользователя-владельца - 1000\newline
ID группы-владельца - 1001\newline
тип устройства - 0\newline
общий размер в байтах - 8\newline
размер блока ввода-вывода - 4096\newline
количество выделенных блоков - 8\newline
время последнего доступа - 1610032547\newline
время последней модификации - 158363166\newline
время последнего изменения - 1610032547\newline

Как видим ссылка создалась:\newline
(base) [anna@Ultra-asus lab2]\$ ls\newline
f.3.txt  f.txt  link     test.txt  z1.cpp  z2.cpp  z3.c  z4.c    z5\newline
f.4.txt  lab    test4.c  z1        z2      z3      z4    z4.cpp \newline z5.cpp\newline
(base) [anna@Ultra-asus lab2]\$\newline

\subsection{Сортировка файлов}
\subsubsection{Техническое задание}
Вывести на экран информацию обо всех файлах в директории, отсортированную по времени последнего изменения файла. 

\subsubsection{Описание основного алгоритма}
Создаём структуру, содержащую объекты: имя файла и время последнего изменения. Открываем директорию и с помощью функции number\_of\_files считаем количество файлов в ней. Далее в цикле заполняем массив структур и выводим название файла и время последнего изменения для дальнейшего сравнения с отсортированным массивом структур. Затем сортируем массив при помощи функции sort и компаратора для неё. И выводим отсортированный массив.

\subsubsection{Руководство пользователя}
Пользователь может ввести в командную строку исполняемый файл и название директории.\newline
(base) [anna@Ultra-asus lab2]\$ ls\newline
f.3.txt  f.txt  link     test.txt  z1.cpp  z2.cpp  z3.c  z4.c    z5\newline
f.4.txt  lab    test4.c  z1        z2      z3      z4    z4.cpp \newline z5.cpp\newline
(base) [anna@Ultra-asus lab2]\$ ./z5\newline /home/anna/projects/3sem/OSIAK/lab2\newline
Фалы в директории:\newline
. 1610032547\newline
.. 1609930200\newline
z1.cpp 1603719335\newline
z1 1603643618\newline
z2.cpp 1603783438\newline
lab 1603697770\newline
z3.c 1603783443\newline
z3 1603722815\newline
test4.c 1603724393\newline
z4.cpp 1603783448\newline
z4.c 1603725407\newline
z5.cpp 1603783454\newline
z4 1603734111\newline
test.txt 1603734169\newline
z2 1603735961\newline
z5 1603780228\newline
f.txt 1610032038\newline
f.3.txt 1610032038\newline
f.4.txt 1610032038\newline
link 1610032547\newline

Отсортированные файлы по времени последнего изменения:\newline
z1 1603643618\newline
lab 1603697770\newline
z1.cpp 1603719335\newline
z3 1603722815\newline
test4.c 1603724393\newline
z4.c 1603725407\newline
z4 1603734111\newline
test.txt 1603734169\newline
z2 1603735961\newline
z5 1603780228\newline
z2.cpp 1603783438\newline
z3.c 1603783443\newline
z4.cpp 1603783448\newline
z5.cpp 1603783454\newline
.. 1609930200\newline
f.txt 1610032038\newline
f.3.txt 1610032038\newline
f.4.txt 1610032038\newline
. 1610032547\newline
link 1610032547\newline
(base) [anna@Ultra-asus lab2]\$ \newline
\newpage

\section{Работа с процессами}
\subsection{Используемые системные объекты}
Для получения PID процесса используется функция getpid(), для создания процесса fork(). Для ожидания завершения дочернего процесса используется функция wait() и waitpid(). Они расплолагаются в библиоткеке <sys/wait.h>.
Функция sleep приостанавливает работу потока, в котором она была вызвана, на указанное в аргументе время или до поступления сигнала по которому вызывается функция обработки сигналов или программа завершает свою работу.

\subsection{Порождение процессов}
\subsubsection{Техническое задание}
Породить  количество  процессов,  заданное  аргументом  командной строки. Если аргумент не указан, то сообщить об этом. Каждый  порождённый  процесс  печатает ФИО автора  программыи пишет свой PID.

\subsubsection{Описание основного алгоритма}
Для начала мы с помощью функции atoi делаем из строки число --- количество процессов. В цикле мы поражадаем процесс, который печатает свой PID и ФИО автора программы, уменьшая на 1 переменную, отвечающую за количество процессов, пока она не станет равна нулю.

\subsubsection{Руководство пользователя}
Пользователь вводит исполняемый файл и целое положительное число --- количество процессов. Например: ./a.out 10.
(base) [anna@Ultra-asus lab3]\$ ./3\_1 5 \newline
Lebedeva Anna Ilinichna, PID: 14028, PPID: 14027 \newline
Lebedeva Anna Ilinichna, PID: 14032, PPID: 14027 \newline
Lebedeva Anna Ilinichna, PID: 14030, PPID: 14027 \newline
Lebedeva Anna Ilinichna, PID: 14031, PPID: 14027 \newline
Lebedeva Anna Ilinichna, PID: 14029, PPID: 14027 \newline
(base) [anna@Ultra-asus lab3]\$\newline

\subsection{Иерархия процессов}
\subsubsection{Техническое задание}
Программа должна принимать имя выходного файла. Если оно не указано, то весь вывод осуществляется на экран. Требуется создать иерархию процессов: Первый процесс создаёт 5 процессов. Каждый из следующих создаёт 4 процесса. Следующее поколении порождает 3 процесса. И так далее. Каждый процесс после порождения других процессов печатает номер PID и PID дочерних процессов в виде: PID: <1 child PID> <2 child PID> <3 child PID> <4 child PID> <5 child PID>. Последние процессы в цепочке ждут 10 сек и после этого завершаются.    Предпоследний процесс ждёт на секунду больше. Остальные аналогично. Основной  процесс после  запуска  всех  дочерних  ждёт  пару  секунд  и выводит   дерево   процессов (вызовом системной функции <<pstree-p>>). Завершиться процесс должен также через секунду после дочерних, т.е. последним. Все запущенные  процессы  должны  быть  пересчитаны и  перед завершением основной  процесс  должен написать приветствие  в  виде  ФИО автора программыи количества всех порождённых процессов.

\subsubsection{Описание основного алгоритма}
Первый процесс создаёт 5 процессов в цикле. Каждый из следующих создаёт 4 процесса. Следующее поколении порождает 3 процесса. И так далее, пока n не станет равен 0. Каждый процесс после порождения других процессов печатает номер PID и PID дочерних процессов. Последние процессы в цепочке ждут 10 сек и после этого завершаются. Предпоследний процесс ждёт на секунду больше. Остальные аналогично. Основной  процесс после  запуска  всех дочерних ждёт пару секунд и выводит дерево  процессов, он завершается последним. Затем все запущенные  процессы пересчитываются при помощи функции count и перед завершением основной  процесс пишет приветствие  в  виде  ФИО автора программы и количества всех порождённых процессов.

\subsubsection{Руководство пользователя}
Пользователь запускает программу и ждёт.

\begin{figure}[h!]
\centering
\includegraphics[scale=0.5]{Снимок экрана_2021-01-09_09-07-26.png}
\caption{Часть вывода PID-ов} 
\label{fig:cube}
\end{figure}
\begin{figure}[h!]
\centering
\includegraphics[scale=0.5]{Снимок экрана_2021-01-02_10-55-02.png}
\caption{Часть вывода ps-tree}
\label{fig:cube}
\end{figure}


\newpage

\subsection{Подсчёт факториалов}
\subsubsection{Техническое задание}
В  аргументах  командной  строки  задаётся  количество  порождаемых процессов (например -n 10) и имя выходного файла (например -o outfile). Если не  указан  ключ <<-n>>,  то  по  умолчанию  нужно  породить  1  процесс.  Если  не указан ключ <<-o>>, то вывод осуществляется на экран. Сначала  порождается  указанное  количество  процессов,  каждый  из которых печатает информацию в   свой   файл <<outfile.PID>>, где PID --- идентификатор порождённого  процесса, <<outfile>> – файл  из  параметров командной  строки(<<out.pid>>,  если  не указанключ <<-o>>).  Каждый  процесс записывает  в  файл  ФИО  автора  и  факториал от (PPID–PID). Основной процесс  ждёт  завершение  всех  процессов,  склеивает  их  в  выходной  файл  и удаляет все промежуточные, если в аргументе командной строки указан ключ <<-c>>.

\subsubsection{Описание основного алгоритма}
В  аргументах  командной  строки  задаётся  количество  порождаемых процессов и имя выходного файла. Если не  указан  ключ <<-n>>, то  порождаем 1  процесс. Если не указан ключ <<-o>>, то вывод осуществляем на экран. Сначала в цикле порождается  указанное  количество  процессов,  каждый  из которых печатает информацию в  свой   файл. В первом цикле каждый  процесс записывает  в  файл  ФИО  автора  и  факториал от (PPID–PID), посчитанный при помощи функции factorial. Затем в условии if(is\_main) основной процесс  ждёт  завершение  всех  процессов. Если указан ключ <<-c>>, то основной процесс в ожидании завершения  всех  процессов,  склеивает  их  в  выходной файл и удаляет все промежуточные. Для хранения PID-ов использовался вектор, для работы с ним использоавлись функции из библиотеки <vector>.


\subsubsection{Руководство пользователя}
Пользователь может ввести просто количество процессов (./a.out 10). Далее может добавить в свой ввод ключ -n (./a.out -n 10). Также может добавить имя выходного файла, если укажет ключ -o (./a.out -n 10 -o outfile.txt). И может добавить ключ -c, чтобы вывод осуществился только в выходной файл (./a.out -n 10 -o outfile.txt -с). \newline
(base) [anna@Ultra-asus lab3]\$ ls \newline
3\_1  3\_1.cpp  3\_2  3\_2.cpp  3\_3  3\_3.cpp \newline
(base) [anna@Ultra-asus lab3]\$ ./3\_3 -n 10 -o out.txt -c\newline
(base) [anna@Ultra-asus lab3]\$ ls\newline
3\_1  3\_1.cpp  3\_2  3\_2.cpp  3\_3  3\_3.cpp  out.txt\newline
(base) [anna@Ultra-asus lab3]\$ ./3\_3 -n 10 -o out.txt\newline
(base) [anna@Ultra-asus lab3]\$ ls\newline
3\_1      3\_2.cpp  out.txt        out.txt.14986  out.txt.14989\newline  out.txt.14992\newline
3\_1.cpp  3\_3      out.txt.14984  out.txt.14987  out.txt.14990 \newline out.txt.14993\newline
3\_2      3\_3.cpp  out.txt.14985  out.txt.14988  out.txt.14991\newline
(base) [anna@Ultra-asus lab3]\$ ./3\_3 -n 10\newline
Lebedeva Anna Ilinichna 1\newline
Lebedeva Anna Ilinichna 2\newline
Lebedeva Anna Ilinichna 6\newline
Lebedeva Anna Ilinichna 24\newline
Lebedeva Anna Ilinichna 120\newline
Lebedeva Anna Ilinichna 720\newline
Lebedeva Anna Ilinichna 5040\newline
Lebedeva Anna Ilinichna 40320\newline
Lebedeva Anna Ilinichna 362880\newline
Lebedeva Anna Ilinichna 3628800\newline
(base) [anna@Ultra-asus lab3]\$ ./3\_3 10\newline
Lebedeva Anna Ilinichna 1\newline
(base) [anna@Ultra-asus lab3]\$ \newline


\newpage

\section{Работа с семафорами}
\subsection{Используемые системные объекты}
 Все необходимые функции для манипуляции семафорами хранятся в заголовке <sys/sem.h> (semget --- открытие и создание (при необходимости) набора семафоров, semop --- запрос и изменение значения семафоров, semctl --- запрос и изменение управляющих параметров набора семафоров, удаление набора). Также там содержится тип данных union semun.\newline
 <sys/shm.h> --- заголовок, содержащий функции для работы с совместно используемой памятью (shmget --- создается совместно используемая память, shmctl --- функция управления совместно используемой памятью, shmdt --- отсоединяет совместно используемую память от текущего процесса).\newline
 Заголовок <sys/ipc.h> используется тремя механизмами для межпроцессного взаимодействия XSI (IPC): сообщениями, семафорами и разделяемой памятью. Все используют общий тип структуры, ipc\_perm, для передачи информации, используемой при определении разрешения на выполнение операции IPC.\newline

\subsection{Задача читателей и писателей}
\subsubsection{Техническое задание}
Реализовать задачу читателей и писателей через семафоры. Суть задачи состоит в следующем:
\begin{enumerate} 
  \item существует 20 процессов: 10 читателей и 10 писателей; 
  \item писатели периодически пишут в файл числа от 0 до 999;
  \item читатели читают файл и считают количество цифр в файле: каждый из читателей подсчитывает свою цифру;
  \item спустя 30 секунд все процессы завершаются, перед этим написав свой PID, роль и количество цифр (для читателей) и сгенерированных чисел (для писателей);
  \item Попытка чтения или записи происходит через случайный интервал времени от 10 до 20 миллисекунд.
\end{enumerate}

\subsubsection{Описание основного алгоритма}
Проверяем корректность ввода. Создаём 7 семафоров, отвечающих за следующие действия: инициализация,
попытка начать читать, позволить другим читателям, конец чтения, попытка начать писать, ждать конец чтения, конец написания. Открываем набор семафоров, инициализируем первый. Затем запускаем процессы читателей и писателей в цикле. Писатели и читатели в случайный интервал времени от 10 до 20 миллисекунд пишут в файл числа от 0 до 999 и считывая файл, считают количество цифр в нём соотвестственно при помощи семафоров описанных ранее, отвечающих за свою задачу. Потом процессы пишут свои PID-ы, роль и количество цифр (для читателей) и сгенерированных чисел (для писателей) и завершаются спустя 30 секунд.

\subsubsection{Руководство пользователя}
Пользователь вводит в командную строку исполняемый файл и название тектового пустого файла. \newline
(base) [anna@Ultra-asus lab4]\$ ./4.1 test.txt \newline
I am  Reader, PID: 37360, Count: 2821236\newline
I am  Reader, PID: 37372, Count: 4544848\newline
I am  Reader, PID: 37374, Count: 4129201\newline
I am  Writer, PID: 37365, Count: 1718\newline
I am  Writer, PID: 37371, Count: 1735\newline
I am  Writer, PID: 37373, Count: 1736\newline
I am  Writer, PID: 37361, Count: 1726\newline
I am  Reader, PID: 37366, Count: 3985856\newline
I am  Writer, PID: 37380, Count: 1727\newline
I am  Writer, PID: 37367, Count: 1736\newline
I am  Reader, PID: 37368, Count: 4280644\newline
I am  Reader, PID: 37377, Count: 4136106\newline
I am  Reader, PID: 37379, Count: 4148620\newline
I am  Reader, PID: 37362, Count: 4379774\newline
I am  Writer, PID: 37369, Count: 1723\newline
I am  Writer, PID: 37363, Count: 1724\newline
I am  Reader, PID: 37370, Count: 4069040\newline
I am  Reader, PID: 37364, Count: 3786668\newline
I am  Writer, PID: 37375, Count: 1727\newline
I am  Writer, PID: 37378, Count: 1718\newline
(base) [anna@Ultra-asus lab4]\$

\subsection{Семафоры и разделяемая память}
\subsubsection{Техническое задание}
Реализовать клиент-сервер на семафорах и разделяемой памяти. Он должен делать следующее:
\begin{enumerate} 
  \item сервер принимает от клиента запросы в виде примера из двух вещественных чисел и бинарной операции между ними;
  \item  сервер возвращает ответ;
  \item клиентов может быть много;
  \item запросы клиенты отправляют в интерактивном режиме;
  \item e.клиент завершается, если пользователь напечатает пустую строку.
\end{enumerate}

\subsubsection{Описание основного алгоритма}
Запускается сервер, клиент запрашивает у пользователя пример из двух вещественных чисел и бинарной операции между ними, затем открывается разделяемая область памяти, потом проверяется открылась ли она. Далее подсоединяет область памяти к виртуальному адресному пространству процесса. Затем клиент конвертирует операнды в числа с плавающей точкой, запрашивает у сервера выполнение операций. Сервер их выполняет и отправляет ответ клиенту.

\subsubsection{Руководство пользователя}
Пользователь запускает сервер, потом может запустить несколько клиентов и пишет на каждой новой строчке операнд, операцию и второй операнд.

Запускаем сервер в одном терминале:

(base) [anna@Ultra-asus lab4]\$ ./4.2server \newline

Клиент в другом:

(base) [anna@Ultra-asus lab4]\$ ./4.2client \newline
Enter your expression (operand expression operand):\newline
3\newline
+\newline
2.5\newline
5.5\newline
(base) [anna@Ultra-asus lab4]\$\newline

\newpage

\section{Работа с каналами и сообщениями}
\subsection{Используемые системные объекты}
pipe ---  создаёт однонаправленный канал данных, который можно использовать для взаимодействия между процессами.

<sys/msg.h> ---  заголовочный файл подключающийся к программам, использующим очереди сообщений, содержит функции: msgget (открытие для доступа и создание очереди сообщений), msgsnd (функция для передачи сообщений в очередь), msgrcv (для приема сообщений из очереди), msgctl (манипулирование управляющими параметрами очереди сообщений).

\subsection{Численное нахождение интеграла}
\subsubsection{Техническое задание}
Реализовать с помощью pipe параллельные вычисления числа $\pi$.
\begin{enumerate} 
  \item Через аргументы командной строки задаётся количество процессов, которые будут применяться для расчётов, и количество разбиений интервала [0; 1).
  \item  Каждый процесс считает число $\pi$ в части интервала от 0 до 1, согласно своему номеру. (Например для 4 процессов первый имеет интервал от [0; 0,25), второй --- [0,25; 0,5), третий --- [0,5; 0,75), четвёртый --- [0,75; 1).
  \item Для расчёта применяется формула численного интегрирования для подсчёта интеграла от 4/(1+$x^2$). Можно использовать формулу прямоугольников.
  \item Каждый дочерний процесс через pipe посылает подсчитанное число родителю. Он всё суммирует.
  \item Родитель печатает результат и показывает известное число $\pi$.
\end{enumerate}

\subsubsection{Описание основного алгоритма}
Через аргументы командной строки принимается количество процессов, которые будут применяться для расчётов, и количество разбиений интервала [0; 1). Затем в цикле for каждый процесс считает число $\pi$ в части интервала от 0 до 1, согласно своему номеру, считая интеграл описанный в функции func, методом прямоугольников integration. Каждый дочерний процесс через pipe посылает подсчитанное число родителю. Он всё суммирует. Родитель печатает результат и показывает число $\pi$.

\subsubsection{Руководство пользователя}
Пользователь вводит исполняемый файл, количество процессов и количество разбиений интервала.

(base) [anna@Ultra-asus lab5]\$ ./5\_1 5 10\newline
3.141526\newline
(base) [anna@Ultra-asus lab5]\$\newline

\subsection{Нахождение корней кубического уравнения}
\subsubsection{Техническое задание}
С помощью очереди сообщений организовать клиент-серверную модель для решения кубического уравнения.
\begin{enumerate} 
  \item Пользователь в клиенте задаёт 4 коэффициента и посылает их серверу в одном сообщении.
  \item  Сервер принимает сообщение и посылает три корня клиенту.
  \item Клиентов может быть много. Каждый из них имеет свой тип сообщений, для определения, куда посылать ответ.
\end{enumerate}

\subsubsection{Описание основного алгоритма}
Запускается сервер. Пользователь в клиенте задаёт 4 коэффициента и посылает их серверу в одном сообщении, добавляя их в структуру Mbuf (хранение информации о сообщении клиента) и отправляет их серверу. Сервер считает корни с помощью метода Кардано (можно и теоремой Виета) и посылает их клиенту.

\subsubsection{Руководство пользователя}
Пользователь запускает сервер, потом клиент в разных терминалах и вводит через пробел 4 коэффициента.

(base) [anna@Ultra-asus lab5]\$ ./5\_2\_server \newline

(base) [anna@Ultra-asus lab5]\$ ./5\_2\_client \newline
Enter ratio of cubic equation (A,B,C,D: Ax + By + Cz + D = 0) \newline
3 4 5 6\newline
x0 = 1.555555555555556\newline
x1 = -1.444444444444444\newline
x2 = -1.444444444444444\newline
(base) [anna@Ultra-asus lab5]\$\newline

\newpage

\section{ПО <<\SOFTWARE>>}

\subsection{Техническое задание}
Требуется разработать клиент-серверное сетевое приложение, реализующее следующий функционал: преобразовать кодировку переданного файла (CP1251, CP866, Koi-8r). 

Запускается сервер, потом клиент. Клиент запрашивает у пользователя название файла, текущую кодировку данного файла и кодировку, в которую нужно преобразовать данный файл. Сервер выводит результат работы программы.

Входные данные: название файла (например: <<test.txt>>), начальная кодировка (например: <<CP1251>>), конечная кодировка (<<CP866>>).

\subsection{Структура приложения}
Socket.h --- заголовок для создания потокового гнезда, содержит функцию error, классы Address и Socket. Они позволяют скрыть от прикладных программ низкоуровневый API гнёзд. Также данный заголовочный файл содержит структуру Package для управления командами между клиентом и сервером. Класс Command --- содержит id команд.
Cтруктура Package содержит два конструктора структуры, функцию clear\_data().
Класс Address содержит функкцию \_name\_to\_host для получения имени для размещения и конструктор Address() для адреса структуры инициализации.
И основной класс Socket содержит два конструктора, деструктор ~Socket(), функции аналогичные API гнёзд: connect, bind, listen, accept. А также функции аналогичные API файлов: write и read.

client.cpp --- блок программы клиента. Клиент вводит необходимые данные, затем вызывается основная функция convert, внутри неё вызываются две дополнительные функции read\_file и iconv для прочтения содержимого файла в текстовом буфере и его перекодировки соответственно. Также функция convert взаимодействует с сервером при помощи функций из заголовка Socket.h, отправляя данные на него.

sеrver.cpp --- блок программы сервера, отвечает на запросы клиента, соблюдает его команды. 

\subsection{Основные алгоритмы}
Socket.h:

\textbf{void error(const char *msg):}

Описание

Печатает сообщение об ошибке и завершает программу.

Параметры

msg --- указатель на строку, которую нужно напечатать.

Возвращаемое значение

Ничего не возвращает, завершая работу.

\textbf{void clear\_data():}

Описание

Очищает буфер данных с помощью функции bzero --- записывает пустые байты.

Параметры

Без параметров.

Возвращаемое значение

Ничего не возвращает.

\textbf{hostent *\_name\_to\_host(const char *name):}

Описание

Получает структуру типа hostent машине с именем name и проверяет наличие данного хоста.

Параметры

Принимает Си-строку name.

Возвращаемое значение

Возвращает структуру host типа hostent.

\textbf{void connect(Address const \&addr):}

Описание

Подключается от клиента.

Параметры

addr --- адрес объекта класса Address, для соединения с гнездом.

Возвращаемое значение 

Нет возвращаемых значений.

\textbf{void bind(Address const \&addr):}

Описание

Привязывает адрес к сокету.

\textbf{void listen():}

Описание

Информируем ОС, что он ожидает ("слушает") запросы связи на данном сокете.

\textbf{Socket accept(Address const \&addr):}

Описание

Подключается к клиенту.

Возвращаемое значение

Возвращает объект класса Socket.

\textbf{void write(const Package \&package):}

Описание

При помощи API файла write записывает данные в слушающий сокет.

Параметры

package --- адрес структуры Package.

Возвращаемое значение

Нет возвращаемых значений.

\textbf{void read(Package \&package):}

Описание

При помощи API файла read читает данные из сокета.

client.cpp:

\textbf{int main():}

Описание

Вводится имя файла, затем его кодировка и потом кодировка для преобразования файла. Далее вызывается функция convert, которую мы опишем дальше.

\textbf{void convert(char *file\_name, char *code\_from, char *code\_to):}

Описание

Подключается к серверу, создает пакет командой <<send\_filename>>, устанавливает размер фрагмента, записывает имя файла в буфер данных, отправляет пакет, затем читает содержимое файла в текстовом буфере с помощью функции read\_file, изменяет кодировку с помощью функции iconv, далее инициализирует новый пакет, отправляет данные по фрагментам, потом передает сигнал о завершении запросов и заканчивает работу, завершая при этом работу сервера.

Параметры

file\_name --- указатель на строку с именем файла;

code\_from --- указатель на строку с названием кодировки файла;

code\_to --- указатель на строку с названием конечной кодировки файла;

Возвращаемое значение

Нет возвращаемых значений.

\textbf{string iconv(string code\_from, string code\_to, string code):}

Описание

Выполняет инициализацию, необходимую для преобразования символов из кодированного набора символов с помощью iconv\_open, затем преобразует последовательность символов с помощью iconv(), освобождает дескриптор преобразования cd с помощью iconv\_close().

Параметры

code\_from --- строка, содержащая название кодировки файла;

code\_to ---  строка, содержащая название конечной кодировки файла;

code --- строка, содержащая текст, который нужно преобразовать;

Возвращаемое значение

Возвращает преобразованную строку.

\textbf{string read\_file(string file\_name):}

Описание

Посимвольно считывает файл, добавляя каждый символ результирующую строку.

Параметры

file\_name --- строка, содержащая название файла.

Возвращаемое значение

Возвращает строку, содержащую текст файла.

server.cpp:

\textbf{int main():}

Описание

Привязывает адрес сервера к сокету, задаёт количество ожидающих клиентских сообщений, затем выполняет команды клиента: выводит имя файла, записывает обновлённые данные в файл, принимает сигнал о завершении запросов, и заканчивает работу.


\subsection{Руководство пользователя}
Запускается сервер, и после в консоль выводится надпись <<Server is running.>>. После этого можно запускать клиент. Он запрашивает имя файла, его кодировку и кодировку, в которую нужно преобразовать файл. После этого сервер печатает <<File encoding converted successfully!!!>>, и завершается работа сервера и клиента.

Пример корректной работы приложения:

Проверяю кодировку файла в терминале и уточняю её в менеджере <<Double Comander>>(На данный момент она <<CP866>>):
(base) [anna@Ultra-asus курсач]\$ file -bi test.txt \newline
text/plain; charset=iso-8859-1 \newline
\begin{figure}[h!]
\centering
\includegraphics[scale=0.5]{Снимок экрана_2021-01-08_17-42-03.png}
\label{fig:cube}
\end{figure}

Запускаю сервер:

(base) [anna@Ultra-asus курсач]\$ ./server \newline
Server is running.\newline

Запускаю клиент и ввожу данные:

(base) [anna@Ultra-asus курсач]\$ ./client \newline
Enter file name: test.txt \newline
Enter file encoding: CP866 \newline
Enter the encoding you want to convert to: CP1251 \newline
(base) [anna@Ultra-asus курсач]\$ \newline

Сервер выдаёт ответ:
(base) [anna@Ultra-asus курсач]\$ ./server \newline
Server is running.\newline
File name: "test.txt"\newline


File encoding converted successfully!!!\newline
(base) [anna@Ultra-asus курсач]\$\newline

Проверяем кодировку:

\begin{figure}[h!]
\centering
\includegraphics[scale=0.5]{Снимок экрана_2021-01-08_17-51-22.png}
\label{fig:cube}
\end{figure}

Как видим программа сработала верно.

Теперь проверим для других кодировок:

(base) [anna@Ultra-asus курсач]\$ ./client \newline
Enter file name: test.txt\newline
Enter file encoding: CP1251\newline
Enter the encoding you want to convert to: KOI-8 \newline
(base) [anna@Ultra-asus курсач]\$ \newline

(base) [anna@Ultra-asus курсач]\$ ./server \newline
Server is running. \newline
File name: "test.txt" \newline


File encoding converted successfully!!!\newline
(base) [anna@Ultra-asus курсач]\$\newline

\begin{figure}[h!]
\centering
\includegraphics[scale=0.5]{Снимок экрана_2021-01-08_17-59-13.png}
\label{fig:cube}
\end{figure}

Данное приложение сработает для любых кодировок.

Опишем реакцию приложения на аномалии ввода.

Если мы введём другую кодировку вместо той в которой находится файл, то приложение будет вести себя непредсказуемо. В каких-то случаях кодировка преобразуеся верно, в каких-то нет, а иногда вообще не преобразовывается. Если введём название файла, который не существует, то он создаётся в той кодировке, которую мы ввели первой. Если неправильно ввести названия кодировок, то сервер начнёт сходить с ума и много раз выводить название файла. 

\section{Список использованных источников}
\begin{enumerate} 
  \item Теренс Чан Системное програмирование на С++ для Unix: пер. с англ. C. Тимачева под редакцией М. Коломыцева --- Киев: Издательская группа BHV, 1997. --- 592 с. 
  \item  Таненбаум Э., Бос Х. Современные операционные системы.  4-еизд.  —  СПб.: Питер,  2015.  —  1120  с.: ил. — (Серия «Классика computer science»)
  \item OpenNET — веб-сайт, русскоязычный интернет-проект, посвящённый открытым и свободным компьютерным технологиям.  — URL : https://opennet.ru/ (дата обращения 09.2020 - 01.2021).
  \item Онлайн справочник программиста на C и C++.  — URL : http://www.c-cpp.ru/ (дата обращения 09.2020 - 01.2021).
\end{enumerate}

\newpage

\section{Приложение}
Здесь приводится код. Каждый файл в своём подразделе.

\subsection{Алгоритм Евклида}\label{code:evclid}
\centerline{\textbf{Файл \texttt{main.c}}}
\begin{minted}{C}
#include <stdio.h>

int NOK(int x, int y)
{
  return x * y / NOD(x, y);
}

int NOD(int x, int y)
{
  while (x != y)
  {
    if (x > y)
      x = x - y;
    else
      y = y - x;
  }
  return x;
}

int main()
{
  int y, x;
  printf("Введите целые числа через пробел: ");
  scanf("%d %d", &x, &y);
  printf("НОД %d НОК %d\n", NOD(x, y), NOK(x, y));
}
\end{minted}
\hrulefill

\subsection{Корректность расстановки скобок}\label{code:scobe}
\centerline{\textbf{Файл \texttt{main.c}}}
\begin{minted}{C}
#include <iostream>
#include <string.h>
using namespace std;
 
int main()
{
 
    char A[80];
    char end_open_skobka; 
    char stack[80];
    int pos = -1;
 
    cout << "Введите текст: " << endl;
    cin.getline(A, 80);
 
    int round, figured, squared;
 
    round = figured = squared = 0;
 
    for (int i=0; i<strlen(A); i++)
    {
        if (A[i] == '(') round++;   
        else
        if (A[i] == ')') round--;     
        else
        if (A[i] == '{') figured++;
        else
        if (A[i] == '}') figured--;
        else
        if (A[i] == '[') squared++;  
        else
        if (A[i] == ']') squared--;     
 
        if ( (A[i] == '(') || (A[i] == '{') || (A[i] == '[') )
        {
            end_open_skobka = A[i];          
            pos++;                     
            stack[pos] = A[i];         
        }
 
        if (round<0 || figured<0 || squared<0)
        {
            cout << "Лишняя закрывающая скобка" << endl;
            break;
        }
 
        if ( ((A[i] == ')') && (end_open_skobka != '('))  ||
             ((A[i] == '}') && (end_open_skobka != '{'))  ||
             ((A[i] == ']') && (end_open_skobka != '[')) )
        {
            cout << "Закрывающая скобка другого типа" << endl;
            break;
        }
 
        if ( (A[i] == ')') || (A[i] == '}') || (A[i] == ']') )
        {
            pos--;                           
            if (pos>=0)
                end_open_skobka = stack[pos];
        }
 
 
    }
 
    if (round || figured || squared)
        cout << "Скобки расставлены неправильно" << endl;
    else
        cout << "Скобки расставлены правильно" << endl;
 
 
    return 0;
}
\end{minted}
\hrulefill

\subsection{Переполнение}\label{code:overfull}
\centerline{\textbf{Файл \texttt{main.c}}}
\begin{minted}{C}
#include <iostream>
#include <limits.h>

using namespace std;

long long int power(long long int num, long long int step)
{
	long long int res = 1;
	for (int i = 0; i < step; i++)
		res = res * num;

	return res;
}

int main()
{
	long long int n, i = 1;
	long long int marker = 1;
	cout << "Напишите число: ";
	cin >> n;
	int a_1 = 0;
	short int a_2 = 1;
	unsigned short int a_3 = 1;
	unsigned short int a_3_pred = 0;
	long long int a_4 = 1;
	unsigned char a_5 = 1;
	unsigned char a_5_pred = 0;


	setlocale (LC_ALL, "RUSSIAN");

	if (n < 0)
	{
		cout << "Введите полоительное число!" << endl;
		exit(1);
	}

	for (i; i < n + 1; i++)
		a_1 = a_1 + i * i;

	cout << "Число = " << n << endl << "Сумма = " << a_1 << endl;

	a_1 = 1;
	i = 0;
	while (a_1 > 0)
	{
		a_1 = marker;
		i++;
		marker = marker + power(i, i);
	}
	cout << "Переполнение INT начиная с n = "<< i - 1 << endl;

	i = 0;
	marker = 1;
	while (a_2 > 0)
	{
		a_2 = marker;
		i++;
		marker = marker + power(i, i);
	}
	cout << "Переполнение SHORT INT начиная с n = " << i - 1 << endl;

	i = 0;
	marker = 1;
	while (a_4 > 0)
	{
		a_4 = marker;
		i++;
		marker = marker + power(i, i);
	}
	cout << "Переполнение LONG INT начиная с n = " << i - 1<< endl;

	i = 0;
	marker = 1;
	while (a_3 >= a_3_pred)
	{
		a_3_pred = a_3;
		a_3 = marker;
		i++;
		marker = marker + power(i, i);
	}
	cout << "Переполнение WORD начиная с n = " << i - 1 << endl;

	i = 0;
	marker = 1;
	while (a_5 >= a_5_pred)
	{
		a_5_pred = a_5;
		a_5 = marker;
		i++;
		marker = marker + power(i, i);
	}
	cout << "Переполнение BYTE начиная с n = " << i - 1 << endl;

	return 0;
}
\end{minted}
\hrulefill

\subsection{Куб в виде суммы}\label{code:cube}
\centerline{\textbf{Файл \texttt{main.c}}}
\begin{minted}{C}
#include <stdlib.h>
#include <stdio.h>

int main()
{
    int n,s;
    printf("Ведите число для возведения в третью степень: ");
    scanf("%d", &n);
    int i = n * (n - 1) + 1, a = 1;
    printf("%d^3 = %d", n, i);
    s=i;
    do
    {
        printf("+");
        a++;
        i += 2;
        s+=i;
        printf("%d", i);
    } while(a != n);

    printf(" = %d", s);

    return 0;
}
\end{minted}
\hrulefill

\subsection{Числа Фибоначчи}\label{code:fib}
\centerline{\textbf{Файл \texttt{main.c}}}
\begin{minted}{C}
#include <stdlib.h>
#include <stdio.h>

int main()
{
    int a = 0, b = 1, i = -1, n;
    scanf("%d", &n);
    while(a < n)
    {
        i++;
        b = a + b;
        a = b - a;
    }
    if (a == n)
    {
        b = a + b;
        a = b - a;
        i++;
    }
    printf("№%d; число Фибоначи: %d\n", i+1, a);
    return 0;
}
\end{minted}
\hrulefill

\subsection{Сумма квадратов}\label{code:summ}
\centerline{\textbf{Файл \texttt{main.c}}}
\begin{minted}{C}
#include <stdio.h>

int main()
{
    int m, i, j;
    scanf("%d", &m);
    for(i  = 1; i < m; i++)
        for(j = 1; j < m; j++)
            if (i * i + j * j == m)  printf("%d %d \n", i * i, j * j);

    return 0;
}
\end{minted}
\hrulefill

\subsection{Реализация ls}\label{code:ls}
\centerline{\textbf{Файл \texttt{main.c}}}
\begin{minted}{C}
#include <sys/types.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <dirent.h>

int main(int argc, char *argv[])
//argv[1] - директория
{
    if (argc != 2)
    {
        printf("2 parameters required\n");
        return -1;
    }
    else
    {
        DIR *dir;
        if ((dir = opendir(argv[1])) == NULL)
        {
            printf("Can\'t open folder\n");
            return -1;
        }
        else
        {
            struct dirent *f_cur;
            while ((f_cur = readdir(dir)) != NULL)
            {
                printf("%s\n", f_cur->d_name);
            }
            printf("Done...\n");
            closedir(dir);
            return 0;
        }
    }
}
\end{minted}
\hrulefill

\subsection{Реализация ls без папок}\label{code:ls-cat}
\centerline{\textbf{Файл \texttt{main.c}}}
\begin{minted}{C}
#include <stdio.h>
#include <dirent.h>

int main()
{
    printf("Enter directory name: ");
    char dirname[30];
    scanf("%s", dirname);
    DIR *dir = opendir(dirname);
    if (dir == NULL)
    {
        printf("Can't open folder\n");
        closedir(dir);
        return -1;
    }
    else
    {
        DIR *tmp;
        struct dirent *f_cur;
        while (f_cur = readdir(dir))
        {
            if ((tmp = opendir(f_cur->d_name)) == NULL)
                printf("%s\n", f_cur->d_name);
            else
                closedir(tmp);
        }
        if (closedir(dir) == -1)
            printf("Error closing directory!\n");
        printf("Done...\n");
        return 0;
    }
}
\end{minted}
\hrulefill

\subsection{Жёсткая ссылка}\label{code:hardlink}
\centerline{\textbf{Файл \texttt{main.c}}}
\begin{minted}{C}
#include <sys/types.h>
#include <string.h>
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdlib.h>

int main(int argc, char *argv[])
{
    FILE *f = open(argv[1], O_WRONLY);
    int len = strlen(argv[2]);
    if (argc != 3)
    {
        printf("3 parameters required\n");
        return -1;
    }
    if (f != NULL)
    {
        while (link(argv[1], argv[2]) == -1)
        {
            perror("link");
            argv[2][len - 5] += 1;
        }
        link(argv[1], argv[2]);
    }
    else
        return 1;
    close(f);
    return 0;
}
\end{minted}
\hrulefill

\subsection{Символическая ссылка}\label{code:symlink}
\centerline{\textbf{Файл \texttt{main.c}}}
\begin{minted}{C}
#include <sys/types.h>
#include <sys/stat.h>
#include <string.h>
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>

int main(int argc, char *argv[])
{
    struct stat buf;
    if (argc != 3)
    {
        printf("3 parameters required\n");
        return -1;
    }
    symlink(argv[1], argv[2]);
    lstat(argv[2], &buf);
    printf("устройство - %d\n"
    "inode - %d\n"
    "режим доступа - %d\n"
     "количество жестких ссылок - %d\n"
    "ID пользователя-владельца - %d\n"
    "ID группы-владельца - %d\n"
    "тип устройства - %d\n"
    "общий размер в байтах - %d\n"
    "размер блока ввода-вывода - %d\n"
    "количество выделенных блоков - %d\n"
    "время последнего доступа - %d\n"
    "время последней модификации - %d\n"
    "время последнего изменения - %d\n",
           buf.st_dev, buf.st_ino,
           buf.st_mode, buf.st_nlink, buf.st_uid, buf.st_gid, buf.st_rdev, buf.st_size,
           
           buf.st_blksize,
           buf.st_blocks, buf.st_atime, buf.st_mtime, buf.st_ctime);
    return 0;
}
\end{minted}
\hrulefill

\subsection{Сортировка файлов}\label{code:sort}
\centerline{\textbf{Файл \texttt{main.c}}}
\begin{minted}{C}
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <dirent.h>

struct File
{
    char *name;
    time_t ctime;
};

typedef int (*Comparer)(struct File *first, struct File *second);

int compare_by_ctime(struct File *first, struct File *second)
{
    if (first->ctime == second->ctime)
    {
        return 0;
    }
    else if (first->ctime < second->ctime)
    {
        return -1;
    }
    return 1;
}

void sort(struct File *file, size_t count, Comparer comparer)
{
    int i, j, comparisonResult;
    struct File temp;
    for (i = 0; i < count - 1; i++)
    {
        for (j = i + 1; j < count; j++)
        {
            comparisonResult = comparer(file + i, file + j);
            if (comparisonResult == 1)
            {
                temp = *(file + i);
                *(file + i) = *(file + j);
                file[j] = temp;
            }
        }
    }
}

int number_of_files(DIR *dir, char *dirname)
{
    if ((dir = opendir(dirname)) == NULL)
    {
        printf("Can't open folder\n");
        return -1;
    }
    int n = 0;
    struct dirent *f_cur;
    while ((f_cur = readdir(dir)) != NULL)
        n++;
    closedir(dir);
    return n;
}

void print_struct_file(struct File *file, size_t count)
{
    int k;
    for (k = 0; k < count; k++)
    {
        printf("%s %d\n", file[k].name, file[k].ctime);
    }
}

int main(int argc, char *argv[])
//argv[1] - директория
{
    if (argc != 2)
        return -1;
    else
    {
        DIR *dir;
        int n = number_of_files(dir, argv[1]), i;
        if ((dir = opendir(argv[1])) == NULL)
            return -1;
        else
        {
            int i;
            struct stat buf;
            struct dirent *f_cur;
            struct File *file = 
            (struct File *)malloc(n * sizeof(struct File));

            printf("Фалы в директории:\n");
            i = 0;
            while ((f_cur = readdir(dir)) != NULL && i < n)
            {
                lstat(f_cur->d_name, &buf);
                file[i].ctime = buf.st_ctime;
                file[i].name = f_cur->d_name;
                printf("%s %d\n", file[i].name, file[i].ctime);
                ++i;
            }
            sort(file, n, compare_by_ctime);
            printf("\nОтсортированные файлы по времени последнего изменения:\n");
            print_struct_file(file, n);
            closedir(dir);
            free(file);
            return 0;
        }
    }
}
\end{minted}
\hrulefill

\subsection{Порождение процессов}\label{code:process}
\centerline{\textbf{Файл \texttt{main.c}}}
\begin{minted}{C}
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <string.h>

int main(int argc, char **argv)
{
    if(argc != 2)
    {
        perror("No arg");
        exit(1);
    }
    int count = atoi(argv[1]);
    while(count)
    {
        count--;
        if(!fork())
        {
            printf("Lebedeva Anna Ilinichna, PID:"
            "%ld, PPID: %ld \n", 
            (long)getpid(),(long)getppid());
            break;
        }
    }

    return 0;
}
\end{minted}
\hrulefill

\subsection{Иерархия процессов}\label{code:hierarchy}
\centerline{\textbf{Файл \texttt{main.c}}}
\begin{minted}{C}
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <string.h>

int count(int level)
{
    int result = 0;
    int tmp = 1;
    for (int n = level; n > 0; n--)
    {
        tmp = tmp * n;
        result += tmp;
    }
    return result;
}

int main()
{
    char to_print[500];
    int i = 0;
    int timer = 15;
    int is_main = 1;
    int init = 5;
    int n = init;
    pid_t fork_pid = fork();

    while (n)
    {
        n--;
        if (!fork())
        {
            i = 0;
            to_print[0] = 0;
            is_main = 0;
            timer--;
            init--;
            n = init;
        }
        else
        {
            i += sprintf(to_print + i, "<child %d>", fork_pid);
        }
    }

    printf("%d : %s\n", getpid(), to_print);

    if (is_main)
    {
        sleep(2);
        system("pstree -p");
        printf("Lebedeva Anna Ilinichna, count %d\n", count(init));
        sleep(timer - 2);
    }
    else
    {
        sleep(timer);
    }

    return 0;
}
\end{minted}
\hrulefill

\subsection{Подсчёт факториалов}\label{code:factorial}
\centerline{\textbf{Файл \texttt{main.c}}}
\begin{minted}{C}
#include <iostream>
#include <string>
#include <vector>
#include <cstdio>
#include <fstream>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <string.h>

using namespace std;
 
int factorial(int n)
{
    int res = 1;
    for (int i = 1; i <= n; ++i)
        res *= i;
    return res;
}

int main(int argc, char **argv)
{
    string a_out_name = "out";
    int n = 1;
    bool a_c = false;
    bool a_o = false;

    for (int i = 1; i < argc; i++)
    {
        if (argv[i][1] == 'c')
            a_c = true;
        if (argv[i][1] == 'n')
            n = atoi(argv[++i]);
        if (argv[i][1] == 'o')
        {
            a_out_name = argv[++i];
            a_o = true;
        }
    }

    vector<pid_t> pids;
    int is_main = 1;
    while (n)
    {
        n--;
        pids.push_back(fork());
        if (!pids.back())
        {
            is_main = 0;
            string filename = a_out_name;
            filename += ".";
            filename += to_string(getpid());
            ofstream out_file(filename);
            out_file << "Lebedeva Anna Ilinichna " <<
            
            factorial(getpid() - getppid()) << endl;
            break;
        }
    }
    if (is_main)
    {
        for (pid_t i : pids)
            waitpid(i, NULL, NULL);
        ofstream out_file;
        if (a_o)
            out_file.open(a_out_name);
        for (long i : pids)
        {
            string filename = a_out_name;
            filename += ".";
            filename += std::to_string(i);
            ifstream in_file(filename);
            if (a_o)
                out_file << in_file.rdbuf();
            else
                cout << in_file.rdbuf();
            if (a_c)
                remove(filename.c_str());
        }
    }
    return 0;
}
\end{minted}
\hrulefill

\subsection{Задача читателей и писателей}\label{code:read-write}
\centerline{\textbf{Файл \texttt{main.c}}}
\begin{minted}{C}
#include <iostream>
#include <fstream>
#include <sys/types.h>
#include <sys/sem.h>
#include <sys/ipc.h>
#include <unistd.h>
#include <ctime>
#include <random>

using namespace std;

#define KEY 44
#define SEMSIZE 2

union semun
{
    int val;
    semid_ds *mbuf;
    ushort *array;
    seminfo *ibuf;
} arg;


int main(int argc, char** argv)
{
    srandom(time(0));
    long long int st_time = time(0);
    ushort arr[BUFSIZ];
    arg.array = arr;

    if(argc == 1)
    {
        perror("No input file");
        exit(1);
    }
    else if(argc > 2)
    {
        perror("A lot of arguments!");
        exit(2);
    }

    ofstream File(argv[1]);
    if(!File.is_open())
    {
        perror("Can't open input file!");
        exit(3);
    }
    File.close();

    sembuf sopS[1] = {{1, 1, 0}};
    sembuf sopr1[2] = {{0, 1, 0}, {1, -1, IPC_NOWAIT}};
    sembuf sopr2[1] = {{1, 1, 0}};
    sembuf sopr3[1] = {{0, -1, 0}};
    sembuf sopw1[1] {{1, -1, IPC_NOWAIT}};
    sembuf sopw2[1] {{0, 0, 0}};
    sembuf sopw3[1] = {{1, 1, 0}};

    int sem_desk;
    if((sem_desk = semget(KEY, SEMSIZE, IPC_CREAT | 0777)) == -1)
    {
        perror("Semget fail");
        exit(4);
    }

    if (semop(sem_desk, sopS, 1) == -1)
    {
        perror("Semop fail");
        exit(3);
    }

    pid_t pid;
    int ppid = getpid();
    int k, id;
    long long int count;
    for(int i = 0; i < 20; i++)
    {
        pid = fork();
        if(pid == -1)
        {
            perror("Fork Error\n");
            exit(5);
        }
        else if(pid == 0)
        {
            k = i % 2;
            id = i / 2;
            count = 0;
            break;
        }
    }

    if(getpid() == ppid)
    {
        sleep(30);

        if (semctl(sem_desk, 0, IPC_RMID, 0) == -1)
        {
            perror("Semctl fail");
            exit(7);
        }
        return 0;
    }

    while((time(0) - st_time) < 30)
    {
        usleep(rand() % 10000 + 10000);
        if(k)
        {
            if (semop(sem_desk, sopw1, 1) != -1) {
                semop(sem_desk, sopw2, 1);

                ofstream File(argv[1], ios::app);
                File << random() % 1000 << endl;
                count++;
                if(!File.is_open())
                {
                    File.close();
                }
                semop(sem_desk, sopw3, 1);
            }
        }
        else
        {
            if (semop(sem_desk, sopr1, 2) != -1) {
                semop(sem_desk, sopr2, 1);

                ifstream File(argv[1], ios::app);
                char curr;
                while(File >> curr)
                {
                    if((curr - '0') == id)
                    {
                        count++;
                    }
                }
                if(!File.is_open())
                {
                    File.close();
                }
                semop(sem_desk, sopr3, 1);
            }
        }
    }
    cout << "I am  " << ((k == 1) ? "Writer" : "Reader") << ", PID:"
    
    << getpid() << ", Count: "<< count << endl;
}
\end{minted}
\hrulefill

\subsection{Семафоры и разделяемая память}\label{code:sem-shm}
\centerline{\textbf{Файл \texttt{client.cpp}}}
\begin{minted}{C}
#include <iostream>
#include <sys/types.h>
#include <sys/sem.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <unistd.h>
#include <string>

using namespace std;

#define SEMKEY 88
#define SHMKEY 97
#define SEMSIZE 2

union semun
{
    int val;
    semid_ds *mbuf;
    ushort *array;
    seminfo *ibuf;
} arg;

bool is_double(string str)
{
    char *err_checker = nullptr;
    double value = strtod(str.c_str(), &err_checker);
    if (err_checker == str.c_str() || *err_checker != '\0')
        return 0;
    return 1;
}

bool is_operation(string str)
{
    if (str.length() != 1)
        return 0;
    if (str[0] != '+' && str[0] != '-' && str[0] != '/' && str[0] != '*')
        return 0;
    return 1;
}

int main()
{
    shmid_ds sbuf;
    double *op1, *op2;
    char *opt, *shmptr;
    string tmp1, tmp2, tmpc;
    int shmd, semd, passed = 0;
    ushort arr[BUFSIZ];
    arg.array = arr;

    sembuf sop1[2]{{0, 0, 0}, {1, -1, 0}};
    sembuf sop2[2]{{0, 1, 0 | IPC_NOWAIT}, {1, 0, 0 | IPC_NOWAIT}};
    sembuf sop3[2]{{0, -1, 0}, {1, -1, 0}};
    sembuf sop4[2]{{0, 0, 0 | IPC_NOWAIT}, {1, 1, 0 | IPC_NOWAIT}};

    while (!passed)
    {
        cout << "Enter your expression (operand expression operand):"
        
        << endl;
        cin >> tmp1 >> tmpc >> tmp2;
        if (is_double(tmp1) && is_operation(tmpc) && is_double(tmp2))
            passed = 1;
        if (!passed)
            cout << "Invalid enter, try again" << endl;
    }

    if ((shmd = shmget(SHMKEY, (sizeof(double) * 2 + sizeof(char)),
    
    0777 | IPC_CREAT)) == -1)
    {
        perror("Shmget error");
        exit(-15);
    }

    if ((semd = semget(SEMKEY, SEMSIZE, 0777)) == -1)
    {
        perror("Semget error");
        exit(-3);
    }
    if (semop(semd, sop1, 2) == -1)
    {
        perror("Semop error");
        exit(-6);
    }

    if (shmctl(shmd, SHM_UNLOCK, &sbuf) == -1)
    {
        perror("Shmctl error");
        exit(-23);
    }

    shmptr = (char *)shmat(shmd, 0, 0);

    if (shmptr == ((char *)-1))
    {
        perror("Shmat error");
        exit(-45);
    }

    op1 = (double *)shmptr;
    opt = (char *)(op1 + sizeof(double));
    op2 = (double *)(opt + sizeof(char));
    *op1 = stod(tmp1);
    *opt = tmpc[0];
    *op2 = stod(tmp2);

    if (shmdt(shmptr) == -1)
    {
        perror("Shmdt error(1)");
        exit(-34);
    }

    if (shmctl(shmd, SHM_UNLOCK, &sbuf) == -1)
    {
        perror("Shmctl error");
        exit(-46);
    }

    if (shmctl(shmd, SHM_LOCK, &sbuf) == -1)
    {
        perror("Shmctl error");
        exit(-35);
    }

    if (semop(semd, sop2, 2) == -1)
    {
        perror("Semop error");
        exit(-15);
    }

    if (semop(semd, sop3, 2) == -1)
    {
        perror("Semop error");
        exit(-66);
    }


    if (semop(semd, sop4, 2) == -1)
    {
        perror("Semop error");
        exit(-77);
    }

    shmptr = (char *)shmat(shmd, 0, 0);

    if (shmptr == ((char *)-1))
    {
        perror("Shmat error");
        exit(-27);
    }

    op1 = (double *)shmptr;
    cout << *op1 << endl;

    if (shmdt(op1) == -1)
    {
        perror("Shmdt error(1)");
        exit(-24);
    }

    if (shmctl(shmd, SHM_LOCK, &sbuf) == -1)
    {
        perror("Shmctl error");
        exit(-52);
    }

}
\end{minted}
\centerline{\textbf{Файл \texttt{server.cpp}}}
\begin{minted}{C}
#include <iostream>
#include <sys/types.h>
#include <sys/sem.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <unistd.h>

using namespace std;

#define SEMKEY 88
#define SHMKEY 97
#define SEMSIZE 2

union semun
{
    int val;
    semid_ds *mbuf;
    ushort *array;
    seminfo *ibuf;
} arg;

int main()
{
    ushort arr[BUFSIZ];
    arg.array = arr;
    shmid_ds sbuf;
    double *op1, *op2;
    char *opt, *shmptr;
    int shmdesk, semdesk;

    sembuf sopS[1] = {{1, 1, 0}};
    sembuf sop1[2]{{0, -1, 0}, {1, 0, 0}};
    sembuf sop2[2]{{0, 0, 0 | IPC_NOWAIT}, {1, 0, 0 | IPC_NOWAIT}};
    sembuf sop3[2]{{0, 1, 0 | IPC_NOWAIT}, {1, 1, 0 | IPC_NOWAIT}};

    if ((shmdesk = shmget(SHMKEY, (sizeof(double) * 2 +
    
    sizeof(char)), 0777)) != -1)
    {
        if (shmctl(shmdesk, IPC_RMID, &sbuf) == -1)
        {
            perror("Shmctl error");
            exit(10);
        }
    }

    if ((shmdesk = shmget(SHMKEY,
    
    (sizeof(double) * 2 + sizeof(char)), 0777 | IPC_CREAT)) == -1)
    {
        perror("Shmget error");
        exit(20);
    }

    if (shmctl(shmdesk, SHM_LOCK, &sbuf) == -1)
    {
        perror("Shmctl error");
        exit(50);
    }

    if ((semdesk = semget(SEMKEY, SEMSIZE, 0777)) != -1)
    {
        if (semctl(semdesk, 0, IPC_RMID, 0) == -1)
        {
            perror("Semctl error");
            exit(-1);
        }
    }

    if ((semdesk = semget(SEMKEY, SEMSIZE, IPC_CREAT | 0777)) == -1)
    {
        perror("Semget error");
        exit(-2);
    }

    if (semop(semdesk, sopS, 1) == -1)
    {
        perror("Semop error");
        exit(-55);
    }

    for(;;)
    {
        if (semop(semdesk, sop1, 2) == -1)
        {
            perror("Semop error");
            exit(-44);
        }

        shmptr = (char *)shmat(shmdesk, 0, 0);

        if (shmptr == ((char *)-1))
        {
            perror("Shmat error");
            exit(30);
        }
        op1 = (double *)shmptr;
        opt = (char *)(op1 + sizeof(double));
        op2 = (double *)(opt + sizeof(char));

        if (*opt == '+')
            *op1 = *op1 + *op2;
        else if (*opt == '*')
            *op1 = *op1 * *op2;
        else if (*opt == '-')
            *op1 = *op1 - *op2;
        else if (*opt == '/')
            *op1 = *op1 / *op2;

        if (shmdt(shmptr) == -1)
        {
            perror("Shmdt error(1)");
            exit(24);
        }

        if (semop(semdesk, sop2, 2) == -1)
        {
            perror("Semop error");
            exit(13);
        }
        if (semop(semdesk, sop3, 2) == -1)
        {
            perror("Semop error");
            exit(34);
        }
        sleep(1);
    }
}
\end{minted}
\hrulefill

\subsection{Численное нахождение интеграла}\label{code:pi}
\centerline{\textbf{Файл \texttt{main.c}}}
\begin{minted}{C}
#include <iostream>
#include <stdlib.h>
#include <unistd.h>

double func(double x)
{
	return (4 / (1 + x * x));
}
double integration(double a, double b, int n)
{
	double H = (b - a) / n;
	double S = (func(a) + func(b)) / 2;
	for (int i = 1; i < n; i++)
	{
		S += func(a + i * H);
	}
	return H * S;
}

int main(int argc, char *argv[])
{
	pid_t pid;
	int file_des[2], count, n, i;
	double pi_part, pi = 0, k, step, m;

	if (argc != 3)
	{
		perror("Wrong arguments");
		return -1;
	}

	count = atoi(argv[1]);
	n = atoi(argv[2]);
	step = 1.0 / n;

	if (pipe(file_des) == -1)
	{
		perror("pipe error ");
		return -1;
	}

	for (i = 0; i < count; i++)
	{
		pid = fork();
		if (pid == 0)
		{
			pi_part = 
			
			integration(i * 1.0 / count, (i + 1) * 1.0 / 
			
			count, n);
			close(file_des[0]);
			write(file_des[1], &pi_part, sizeof(pi_part));
			close(file_des[1]);
			return 0;
		}
	}
	if (pid != 0)
	{
		close(file_des[1]);
		while (read(file_des[0], &m, sizeof(m)))
			pi += m;
		printf("%lf\n", pi);
		close(file_des[0]);
	}
}
\end{minted}
\hrulefill

\subsection{Нахождение корней кубического уравнения}\label{code:cube-equation}
\centerline{\textbf{Файл \texttt{client.cpp}}}
\begin{minted}{C}
#include <iostream>
#include <math.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <cstring>
#include <sys/ipc.h>
#include <sys/msg.h>

using namespace std;

struct Cell
{
    double real;
    double imag;
};

struct Mbuf
{
    long mtype;
    Cell answer[3];
    int child_pid;
    int ratio[4] = {0, 0, 0, 0};
};

int main()
{
  int a, b, c, d, i, len, select;
  int mypid = getpid();
  struct Mbuf mobj;
  int fd = msgget(2348, 0);

  for(;;)
  {
    cout << 
    
    "Enter ratio of cubic equation (A,B,C,D: Ax + By + Cz + D = 0)"
    
    << endl;
    cin >> a >> b >> c >> d;
    mobj.ratio[0] = a;
    mobj.ratio[1] = b;
    mobj.ratio[2] = c;
    mobj.ratio[3] = d;

    mobj.child_pid = mypid;
    mobj.mtype = 15;

    len = sizeof(mobj.answer);
    msgsnd(fd, &mobj, 1024, IPC_NOWAIT);
    sleep(1);
    if (msgrcv(fd, &mobj, 1024, mypid, IPC_NOWAIT | MSG_NOERROR) > 0)
    {
      for (i = 0; i < 3; i++)
      {
        if (mobj.answer[i].imag == 0.0)
          printf("x%d = %.15lf\n", i, mobj.answer[i].real);
        else
          printf("x%d = %.15lf + i * %.15lf\n",
          
          i, mobj.answer[i].real, mobj.answer[i].imag);
      }
    }

    break;
  }

  return 0;
}
\end{minted}
\hrulefill

\subsection{ПО <<\SOFTWARE>>}\label{code:soft}
\centerline{\textbf{Файл \texttt{socket.h}}}
\begin{minted}{C}
#include <cstdlib>
#include <cstdio>
#include <sys/socket.h>
#include <netinet/in.h>
#include <cstring>
#include <unistd.h>
#include <netdb.h>

constexpr int port{20001};
constexpr char *host_name{"localhost"};

void error(const char *msg)
{
    perror(msg);
    perror("\n");
    exit(1);
}

enum class Command : char
{
    send_filename = 0X00, // передать имя файла
    send_file = 0X01,     // отправляем файл
    check = 0X10,         // передаем сигнал о завершении запросов
    stop = 0X11           // остановка сервера
};

struct Package
{
    static constexpr size_t MAX_FRAGMENT_SIZE{1024};

    char protocol_code{42};
    Command cmd;
    int32_t num_of_fragments;
    int32_t fragment_num;
    int16_t fragment_size;
    char data[MAX_FRAGMENT_SIZE];

    Package()
        : num_of_fragments{1}, fragment_num{1}, fragment_size{}
    {
        bzero(data, MAX_FRAGMENT_SIZE);
    }

    explicit Package(Command cmd_) : Package()
    {
        cmd = cmd_;
    }

    void clear_data()
    {
        bzero(data, MAX_FRAGMENT_SIZE);
    }
};

class Address
{
    hostent *_name_to_host(const char *name)
    {
        hostent *host{gethostbyname(name)};

        if (!host)
            error("no such host");

        return host;
    }

public:
    sockaddr_in addr;

    Address() = default;

    explicit Address(int port, const char *name = "")
    {
        // адрес структуры инициализации

        bzero((char *)&addr, sizeof(addr));

        addr.sin_family = AF_INET;
        addr.sin_port = htons(port);

        if (strlen(name))
        {
            hostent *host{_name_to_host(name)};

            bcopy((char *)host->h_addr, (char *)&addr.sin_addr.s_addr, host->h_length);

            return;
        }

        addr.sin_family = AF_INET;
        addr.sin_addr.s_addr = INADDR_ANY;
    }
};

class Socket
{
    int _sockfd;

public:
    Socket()
    {
        _sockfd = socket(AF_INET, SOCK_STREAM, 0);

        if (_sockfd < 0)
            error("can't open socket");
    }

    explicit Socket(int sockfd) : _sockfd{sockfd}
    {
    }

    void connect(Address const &addr)
    {

        if (::connect(_sockfd, (sockaddr *)&addr.addr, sizeof(addr.addr)) < 0)
            error("can't connect");
    }

    void bind(Address const &addr)
    {

        if (::bind(_sockfd, (sockaddr *)&addr.addr, sizeof(addr.addr)) < 0)
            error("can't bind");
    }

    void listen()
    {
        ::listen(_sockfd, 1);
    }

    Socket accept(Address const &addr)
    {
        socklen_t addr_len{sizeof(addr.addr)};

        int new_sockfd{::accept(_sockfd, (sockaddr *)&addr.addr, &addr_len)};

        if (new_sockfd < 0)
            error("can't accept");

        return Socket(new_sockfd);
    }

    void write(const Package &package)
    {
        if (::write(_sockfd, &package, sizeof(Package)) < 0)
            error("can't write");
    }

    void read(Package &package)
    {
        if (::read(_sockfd, &package, sizeof(Package)) < 0)
            error("can't read");
    }

    ~Socket()
    {
        close(_sockfd);
    }
};
\end{minted}
\centerline{\textbf{Файл \texttt{client.cpp}}}
\begin{minted}{C}
#include <cstring>
#include <fstream>
#include <iostream>
#include <string>
#include <iconv.h>
#include <errno.h>
#include <err.h>
#include "socket.h"

using namespace std;

string read_file(string file_name)
{
    ifstream fin{file_name};
    string res;

    char ch;
    while ((ch = fin.get()) != EOF)
        res += ch;

    return res;
}

string iconv(string code_from, string code_to, string code)
{
    iconv_t cd;
    size_t k, f, t;
    int se;
    int need_size = code.length();
    char* in = (char*)code.c_str();
    char buf[need_size*2];
    char* out = buf;
 
    cd = iconv_open(code_to.c_str(), code_from.c_str());
    if (cd == (iconv_t)(-1)) err(1, "iconv_open");
    f = strlen(code.c_str());
    t = sizeof buf;
    errno = 0;
    k = iconv(cd, &in, &f, &out, &t);
    se = errno;
 
    iconv_close(cd);
 
    return buf;
}

void convert(char *file_name, char *code_from, char *code_to)
{
    Address addr{port, host_name};
    Socket socket;

    socket.connect(addr);

    Package package{Command::send_filename};
    package.fragment_size = strlen(file_name) + 1;
    strcpy(package.data, file_name);
    socket.write(package);

    string text{read_file(file_name)};

    string conv_text{iconv(code_from, code_to, text)};

    package.cmd = Command::send_file;
    package.num_of_fragments = 
    
    conv_text.size() / Package::MAX_FRAGMENT_SIZE +
    
    bool(conv_text.size() % Package::MAX_FRAGMENT_SIZE);
    size_t i{};

    package.fragment_size = Package::MAX_FRAGMENT_SIZE;
    for (package.fragment_num = 0; package.fragment_num < conv_text.size()
    
    / Package::MAX_FRAGMENT_SIZE; ++package.fragment_num)
    {
        for (int j{}; j < Package::MAX_FRAGMENT_SIZE; ++i, ++j)
            package.data[j] = conv_text[i];

        socket.write(package);
    }

    package.clear_data();

    package.fragment_size = conv_text.size() % Package::MAX_FRAGMENT_SIZE;
    for (int j{}; i < conv_text.size(); ++i, ++j)
        package.data[j] = conv_text[i];

    socket.write(package);

    socket.write(Package(Command::check));

    socket.read(package);

    if (strcmp(file_name, package.data))
        error("bad file name");

    socket.write(Package(Command::stop));
}

int main()
{
    char enter[BUFSIZ], code_from[BUFSIZ], code_to[BUFSIZ];
    cout << "Enter file name: ";
    cin >> enter;

    cout << "Enter file encoding: ";
    cin >> code_from;

    cout << "Enter the encoding you want to convert to: ";
    cin >> code_to;

    convert(enter, code_from, code_to);

    return 0;
}

\end{minted}
\centerline{\textbf{Файл \texttt{server.cpp}}}
\begin{minted}{C}
#include <iostream>
#include <fstream>
#include "socket.h"

using namespace std;

int main()
{
    Address server_addr{port};
    Socket listener;

    listener.bind(server_addr);
    listener.listen();

    cout << "Server is running." << endl;

    Address client_addr;
    Socket socket{listener.accept(client_addr)};

    Package package;
    bool stop{false};
    char file_name[Package::MAX_FRAGMENT_SIZE] = "\0";
    ofstream out;

    do
    {
        socket.read(package);

        switch (package.cmd)
        {
        case Command::send_filename:
            strcpy(file_name, package.data);

            cout << "File name: \"";
            cout << file_name << '\"' << endl
                 << endl;

            break;

        case Command::send_file:
            out.open(file_name);
            for (int i{}; i < package.fragment_size; ++i)
                out << package.data[i];
            cout << endl;
            out.close();
            break;

        case Command::check:
            package.fragment_size = strlen(file_name) + 1;
            strcpy(package.data, file_name);
            socket.write(package);
            cout << "File encoding converted successfully!!!" << endl;
            break;

        case Command::stop:
            stop = true;
            break;
        }
    } while (!stop);

    return 0;
}
\end{minted}
\hrulefill

\end{document}
